// Code generated by moq; DO NOT EDIT.
// github.com/matryer/moq

package fake

import (
	"sync"

	"go.opentelemetry.io/otel/metric/instrument"
	"go.opentelemetry.io/otel/metric/instrument/syncint64"
)

// ITracerProviderSyncInt64Mock is a mock implementation of interfaces.ITracerProviderSyncInt64.
//
//	func TestSomethingThatUsesITracerProviderSyncInt64(t *testing.T) {
//
//		// make and configure a mocked interfaces.ITracerProviderSyncInt64
//		mockedITracerProviderSyncInt64 := &ITracerProviderSyncInt64Mock{
//			CounterFunc: func(name string, opts ...instrument.Option) (syncint64.Counter, error) {
//				panic("mock out the Counter method")
//			},
//			HistogramFunc: func(name string, opts ...instrument.Option) (syncint64.Histogram, error) {
//				panic("mock out the Histogram method")
//			},
//			UpDownCounterFunc: func(name string, opts ...instrument.Option) (syncint64.UpDownCounter, error) {
//				panic("mock out the UpDownCounter method")
//			},
//		}
//
//		// use mockedITracerProviderSyncInt64 in code that requires interfaces.ITracerProviderSyncInt64
//		// and then make assertions.
//
//	}
type ITracerProviderSyncInt64Mock struct {
	// CounterFunc mocks the Counter method.
	CounterFunc func(name string, opts ...instrument.Option) (syncint64.Counter, error)

	// HistogramFunc mocks the Histogram method.
	HistogramFunc func(name string, opts ...instrument.Option) (syncint64.Histogram, error)

	// UpDownCounterFunc mocks the UpDownCounter method.
	UpDownCounterFunc func(name string, opts ...instrument.Option) (syncint64.UpDownCounter, error)

	// calls tracks calls to the methods.
	calls struct {
		// Counter holds details about calls to the Counter method.
		Counter []struct {
			// Name is the name argument value.
			Name string
			// Opts is the opts argument value.
			Opts []instrument.Option
		}
		// Histogram holds details about calls to the Histogram method.
		Histogram []struct {
			// Name is the name argument value.
			Name string
			// Opts is the opts argument value.
			Opts []instrument.Option
		}
		// UpDownCounter holds details about calls to the UpDownCounter method.
		UpDownCounter []struct {
			// Name is the name argument value.
			Name string
			// Opts is the opts argument value.
			Opts []instrument.Option
		}
	}
	lockCounter       sync.RWMutex
	lockHistogram     sync.RWMutex
	lockUpDownCounter sync.RWMutex
}

// Counter calls CounterFunc.
func (mock *ITracerProviderSyncInt64Mock) Counter(name string, opts ...instrument.Option) (syncint64.Counter, error) {
	if mock.CounterFunc == nil {
		panic("ITracerProviderSyncInt64Mock.CounterFunc: method is nil but ITracerProviderSyncInt64.Counter was just called")
	}
	callInfo := struct {
		Name string
		Opts []instrument.Option
	}{
		Name: name,
		Opts: opts,
	}
	mock.lockCounter.Lock()
	mock.calls.Counter = append(mock.calls.Counter, callInfo)
	mock.lockCounter.Unlock()
	return mock.CounterFunc(name, opts...)
}

// CounterCalls gets all the calls that were made to Counter.
// Check the length with:
//
//	len(mockedITracerProviderSyncInt64.CounterCalls())
func (mock *ITracerProviderSyncInt64Mock) CounterCalls() []struct {
	Name string
	Opts []instrument.Option
} {
	var calls []struct {
		Name string
		Opts []instrument.Option
	}
	mock.lockCounter.RLock()
	calls = mock.calls.Counter
	mock.lockCounter.RUnlock()
	return calls
}

// Histogram calls HistogramFunc.
func (mock *ITracerProviderSyncInt64Mock) Histogram(name string, opts ...instrument.Option) (syncint64.Histogram, error) {
	if mock.HistogramFunc == nil {
		panic("ITracerProviderSyncInt64Mock.HistogramFunc: method is nil but ITracerProviderSyncInt64.Histogram was just called")
	}
	callInfo := struct {
		Name string
		Opts []instrument.Option
	}{
		Name: name,
		Opts: opts,
	}
	mock.lockHistogram.Lock()
	mock.calls.Histogram = append(mock.calls.Histogram, callInfo)
	mock.lockHistogram.Unlock()
	return mock.HistogramFunc(name, opts...)
}

// HistogramCalls gets all the calls that were made to Histogram.
// Check the length with:
//
//	len(mockedITracerProviderSyncInt64.HistogramCalls())
func (mock *ITracerProviderSyncInt64Mock) HistogramCalls() []struct {
	Name string
	Opts []instrument.Option
} {
	var calls []struct {
		Name string
		Opts []instrument.Option
	}
	mock.lockHistogram.RLock()
	calls = mock.calls.Histogram
	mock.lockHistogram.RUnlock()
	return calls
}

// UpDownCounter calls UpDownCounterFunc.
func (mock *ITracerProviderSyncInt64Mock) UpDownCounter(name string, opts ...instrument.Option) (syncint64.UpDownCounter, error) {
	if mock.UpDownCounterFunc == nil {
		panic("ITracerProviderSyncInt64Mock.UpDownCounterFunc: method is nil but ITracerProviderSyncInt64.UpDownCounter was just called")
	}
	callInfo := struct {
		Name string
		Opts []instrument.Option
	}{
		Name: name,
		Opts: opts,
	}
	mock.lockUpDownCounter.Lock()
	mock.calls.UpDownCounter = append(mock.calls.UpDownCounter, callInfo)
	mock.lockUpDownCounter.Unlock()
	return mock.UpDownCounterFunc(name, opts...)
}

// UpDownCounterCalls gets all the calls that were made to UpDownCounter.
// Check the length with:
//
//	len(mockedITracerProviderSyncInt64.UpDownCounterCalls())
func (mock *ITracerProviderSyncInt64Mock) UpDownCounterCalls() []struct {
	Name string
	Opts []instrument.Option
} {
	var calls []struct {
		Name string
		Opts []instrument.Option
	}
	mock.lockUpDownCounter.RLock()
	calls = mock.calls.UpDownCounter
	mock.lockUpDownCounter.RUnlock()
	return calls
}
