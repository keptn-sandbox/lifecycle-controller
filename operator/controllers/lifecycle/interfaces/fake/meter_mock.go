// Code generated by moq; DO NOT EDIT.
// github.com/matryer/moq

package fake

import (
	"context"
	"sync"

	"go.opentelemetry.io/otel/metric/instrument"
	"go.opentelemetry.io/otel/metric/instrument/asyncfloat64"
	"go.opentelemetry.io/otel/metric/instrument/asyncint64"
	"go.opentelemetry.io/otel/metric/instrument/syncfloat64"
	"go.opentelemetry.io/otel/metric/instrument/syncint64"
)

// IMeterMock is a mock implementation of interfaces.IMeter.
//
//	func TestSomethingThatUsesIMeter(t *testing.T) {
//
//		// make and configure a mocked interfaces.IMeter
//		mockedIMeter := &IMeterMock{
//			AsyncFloat64Func: func() asyncfloat64.InstrumentProvider {
//				panic("mock out the AsyncFloat64 method")
//			},
//			AsyncInt64Func: func() asyncint64.InstrumentProvider {
//				panic("mock out the AsyncInt64 method")
//			},
//			RegisterCallbackFunc: func(insts []instrument.Asynchronous, function func(context.Context)) error {
//				panic("mock out the RegisterCallback method")
//			},
//			SyncFloat64Func: func() syncfloat64.InstrumentProvider {
//				panic("mock out the SyncFloat64 method")
//			},
//			SyncInt64Func: func() syncint64.InstrumentProvider {
//				panic("mock out the SyncInt64 method")
//			},
//		}
//
//		// use mockedIMeter in code that requires interfaces.IMeter
//		// and then make assertions.
//
//	}
type IMeterMock struct {
	// AsyncFloat64Func mocks the AsyncFloat64 method.
	AsyncFloat64Func func() asyncfloat64.InstrumentProvider

	// AsyncInt64Func mocks the AsyncInt64 method.
	AsyncInt64Func func() asyncint64.InstrumentProvider

	// RegisterCallbackFunc mocks the RegisterCallback method.
	RegisterCallbackFunc func(insts []instrument.Asynchronous, function func(context.Context)) error

	// SyncFloat64Func mocks the SyncFloat64 method.
	SyncFloat64Func func() syncfloat64.InstrumentProvider

	// SyncInt64Func mocks the SyncInt64 method.
	SyncInt64Func func() syncint64.InstrumentProvider

	// calls tracks calls to the methods.
	calls struct {
		// AsyncFloat64 holds details about calls to the AsyncFloat64 method.
		AsyncFloat64 []struct {
		}
		// AsyncInt64 holds details about calls to the AsyncInt64 method.
		AsyncInt64 []struct {
		}
		// RegisterCallback holds details about calls to the RegisterCallback method.
		RegisterCallback []struct {
			// Insts is the insts argument value.
			Insts []instrument.Asynchronous
			// Function is the function argument value.
			Function func(context.Context)
		}
		// SyncFloat64 holds details about calls to the SyncFloat64 method.
		SyncFloat64 []struct {
		}
		// SyncInt64 holds details about calls to the SyncInt64 method.
		SyncInt64 []struct {
		}
	}
	lockAsyncFloat64     sync.RWMutex
	lockAsyncInt64       sync.RWMutex
	lockRegisterCallback sync.RWMutex
	lockSyncFloat64      sync.RWMutex
	lockSyncInt64        sync.RWMutex
}

// AsyncFloat64 calls AsyncFloat64Func.
func (mock *IMeterMock) AsyncFloat64() asyncfloat64.InstrumentProvider {
	if mock.AsyncFloat64Func == nil {
		panic("IMeterMock.AsyncFloat64Func: method is nil but IMeter.AsyncFloat64 was just called")
	}
	callInfo := struct {
	}{}
	mock.lockAsyncFloat64.Lock()
	mock.calls.AsyncFloat64 = append(mock.calls.AsyncFloat64, callInfo)
	mock.lockAsyncFloat64.Unlock()
	return mock.AsyncFloat64Func()
}

// AsyncFloat64Calls gets all the calls that were made to AsyncFloat64.
// Check the length with:
//
//	len(mockedIMeter.AsyncFloat64Calls())
func (mock *IMeterMock) AsyncFloat64Calls() []struct {
} {
	var calls []struct {
	}
	mock.lockAsyncFloat64.RLock()
	calls = mock.calls.AsyncFloat64
	mock.lockAsyncFloat64.RUnlock()
	return calls
}

// AsyncInt64 calls AsyncInt64Func.
func (mock *IMeterMock) AsyncInt64() asyncint64.InstrumentProvider {
	if mock.AsyncInt64Func == nil {
		panic("IMeterMock.AsyncInt64Func: method is nil but IMeter.AsyncInt64 was just called")
	}
	callInfo := struct {
	}{}
	mock.lockAsyncInt64.Lock()
	mock.calls.AsyncInt64 = append(mock.calls.AsyncInt64, callInfo)
	mock.lockAsyncInt64.Unlock()
	return mock.AsyncInt64Func()
}

// AsyncInt64Calls gets all the calls that were made to AsyncInt64.
// Check the length with:
//
//	len(mockedIMeter.AsyncInt64Calls())
func (mock *IMeterMock) AsyncInt64Calls() []struct {
} {
	var calls []struct {
	}
	mock.lockAsyncInt64.RLock()
	calls = mock.calls.AsyncInt64
	mock.lockAsyncInt64.RUnlock()
	return calls
}

// RegisterCallback calls RegisterCallbackFunc.
func (mock *IMeterMock) RegisterCallback(insts []instrument.Asynchronous, function func(context.Context)) error {
	if mock.RegisterCallbackFunc == nil {
		panic("IMeterMock.RegisterCallbackFunc: method is nil but IMeter.RegisterCallback was just called")
	}
	callInfo := struct {
		Insts    []instrument.Asynchronous
		Function func(context.Context)
	}{
		Insts:    insts,
		Function: function,
	}
	mock.lockRegisterCallback.Lock()
	mock.calls.RegisterCallback = append(mock.calls.RegisterCallback, callInfo)
	mock.lockRegisterCallback.Unlock()
	return mock.RegisterCallbackFunc(insts, function)
}

// RegisterCallbackCalls gets all the calls that were made to RegisterCallback.
// Check the length with:
//
//	len(mockedIMeter.RegisterCallbackCalls())
func (mock *IMeterMock) RegisterCallbackCalls() []struct {
	Insts    []instrument.Asynchronous
	Function func(context.Context)
} {
	var calls []struct {
		Insts    []instrument.Asynchronous
		Function func(context.Context)
	}
	mock.lockRegisterCallback.RLock()
	calls = mock.calls.RegisterCallback
	mock.lockRegisterCallback.RUnlock()
	return calls
}

// SyncFloat64 calls SyncFloat64Func.
func (mock *IMeterMock) SyncFloat64() syncfloat64.InstrumentProvider {
	if mock.SyncFloat64Func == nil {
		panic("IMeterMock.SyncFloat64Func: method is nil but IMeter.SyncFloat64 was just called")
	}
	callInfo := struct {
	}{}
	mock.lockSyncFloat64.Lock()
	mock.calls.SyncFloat64 = append(mock.calls.SyncFloat64, callInfo)
	mock.lockSyncFloat64.Unlock()
	return mock.SyncFloat64Func()
}

// SyncFloat64Calls gets all the calls that were made to SyncFloat64.
// Check the length with:
//
//	len(mockedIMeter.SyncFloat64Calls())
func (mock *IMeterMock) SyncFloat64Calls() []struct {
} {
	var calls []struct {
	}
	mock.lockSyncFloat64.RLock()
	calls = mock.calls.SyncFloat64
	mock.lockSyncFloat64.RUnlock()
	return calls
}

// SyncInt64 calls SyncInt64Func.
func (mock *IMeterMock) SyncInt64() syncint64.InstrumentProvider {
	if mock.SyncInt64Func == nil {
		panic("IMeterMock.SyncInt64Func: method is nil but IMeter.SyncInt64 was just called")
	}
	callInfo := struct {
	}{}
	mock.lockSyncInt64.Lock()
	mock.calls.SyncInt64 = append(mock.calls.SyncInt64, callInfo)
	mock.lockSyncInt64.Unlock()
	return mock.SyncInt64Func()
}

// SyncInt64Calls gets all the calls that were made to SyncInt64.
// Check the length with:
//
//	len(mockedIMeter.SyncInt64Calls())
func (mock *IMeterMock) SyncInt64Calls() []struct {
} {
	var calls []struct {
	}
	mock.lockSyncInt64.RLock()
	calls = mock.calls.SyncInt64
	mock.lockSyncInt64.RUnlock()
	return calls
}
