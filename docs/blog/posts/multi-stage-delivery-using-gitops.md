---
date: 2024-03-27
authors: [bacherfl]
description: >
  This blog post explains how to use the promotion phase of Keptn to implement a multi stage delivery GitOps workflow.
categories:
  - GitOps
  - Observability
comments: true
---

# Multi Stage Delivery using GitOps

In multi-stage environments it can often become a challenge to keep an overview of
how a particular version of a workload progresses through different stages.
This can make it difficult to trace back which exact introduced a problem
when something goes wrong in one of the deployment stages.

Having a distributed OpenTelemetry trace that encompasses all
deployment stages and contains all relevant information,
such as the git commit ID that triggered the deployment of a workload,
helps to address this challenge.
For example, if the evaluation of a load test in one of the deployment stages
is failing, the distributed trace generated by Keptn not only contains
details about the result of the evaluation, but also a link to the
deployment trace of the previous stage.
This makes it easy to trace back the deployment of that particular workload
across the previous stages, right until the original commit that resulted in
the performance degradation.

This blog post demonstrates an example workflow that automates the promotion
of a sample application across two different stages.
The deployment traces of those stages are linked together and enriched
with valuable metadata, such as the commit ID that triggered the deployment
of a new workload version.

For this, we are using the following technologies:

- The new [KeptnAppContext CRD](../../docs/reference/crd-reference/appcontext.md)
  that allows to pass metadata to the generated deployment traces, and define a `promotion`
  task that is executed once the application is deployed and all post deployment checks have been
  executed successfully.
- [ArgoCD](https://argoproj.github.io/cd/) as a GitOps tool.
  In addition to automatically synchronising the cluster with the desired
  state of the cluster, ArgoCD also adds metadata such as the git commit ID
  that triggered the last sync to the `KeptnAppContext` CRD.
- [GitHub Actions](https://github.com/features/actions): With the GitOps
  repository being hosted on GitHub, we are making use of GitHub Actions
  to implement the promotion of an artifact from one stage to the next by
  running a workflow that creates the pull requests for updating the
  application manifests in the different stages.
- [Helm](https://helm.sh): The configuration of the application in both stages
  is maintained via two separate helm charts respectively.
- [OpenTelemetry Collector](https://opentelemetry.io/docs/collector/)/[Jaeger](https://www.jaegertracing.io):
  The deployment traces are gathered by the OpenTelemetry Collector and forwarded to Jaeger,
  where we can view the generated traces.

## Setting up the Environment

Now it's time to set up our environment and connect all the tools mentioned above
with each other.

### Set up the GitHub repository

First things first, since we talk about GitOps in this article, we need
a git repository to host the helm chart of our application.
In this example, we are using GitHub, since this also allows us
to make use of GitHub Actions to implement the promotion from
`dev` to `production`.

In this example, we are using [this repository](https://github.com/bacherfl/keptn-analysis-demo)
as an upstream repository.
If you would like to try the demo yourself, feel free to fork this repository
and start experimenting with Keptn from there.
